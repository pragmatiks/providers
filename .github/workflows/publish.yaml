name: Publish Providers

on:
  push:
    branches:
      - main

# Provider dependency chain (publish in this order):
# 1. gcp (no internal deps)
# 2. kubernetes (depends on gcp), qdrant (depends on kubernetes)
# 3. agno (depends on gcp, kubernetes)
#
# We publish each tier sequentially to ensure dependencies are available on PyPI.

jobs:
  detect-changes:
    if: "!startsWith(github.event.head_commit.message, 'bump:')"
    runs-on: ubuntu-latest
    outputs:
      gcp: ${{ steps.changes.outputs.gcp }}
      qdrant: ${{ steps.changes.outputs.qdrant }}
      kubernetes: ${{ steps.changes.outputs.kubernetes }}
      agno: ${{ steps.changes.outputs.agno }}
      has_changes: ${{ steps.changes.outputs.has_changes }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed providers
        id: changes
        run: |
          # Get changed files since last provider tag or last commit
          LAST_TAG=$(git tag -l "*-v*" --sort=-version:refname | head -1 || echo "")
          if [ -n "$LAST_TAG" ]; then
            CHANGED_FILES=$(git diff --name-only "$LAST_TAG"..HEAD)
          else
            CHANGED_FILES=$(git diff --name-only HEAD~1..HEAD 2>/dev/null || git ls-files)
          fi

          # Check each provider individually
          HAS_CHANGES=false

          for provider in gcp qdrant kubernetes agno; do
            if echo "$CHANGED_FILES" | grep -q "^packages/$provider/"; then
              echo "$provider=true" >> $GITHUB_OUTPUT
              echo "Changed: $provider"
              HAS_CHANGES=true
            else
              echo "$provider=false" >> $GITHUB_OUTPUT
            fi
          done

          echo "has_changes=$HAS_CHANGES" >> $GITHUB_OUTPUT

  # Tier 1: Base providers with no internal dependencies
  publish-tier-1:
    needs: detect-changes
    if: needs.detect-changes.outputs.gcp == 'true'
    runs-on: ubuntu-latest
    environment: pypi
    permissions:
      contents: write
      id-token: write
    outputs:
      gcp_version: ${{ steps.bump.outputs.gcp_version }}

    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token }}

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          version: "0.5.x"

      - name: Set up Python
        run: uv python install 3.13

      - name: Install commitizen
        run: uv tool install commitizen

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Bump and build gcp
        id: bump
        run: |
          echo "::group::Processing gcp"
          cd packages/gcp

          if cz bump --yes --changelog 2>&1 | tee bump_output.txt; then
            VERSION=$(cz version --project)
            echo "Bumped gcp to v$VERSION"
            echo "gcp_version=$VERSION" >> $GITHUB_OUTPUT
            uv build --package pragmatiks-gcp-provider --out-dir ../../dist
          else
            if grep -qE "No commits found|is not a bump" bump_output.txt; then
              echo "No bump needed for gcp"
            else
              cat bump_output.txt
              exit 1
            fi
          fi

          cd ../..
          echo "::endgroup::"

      - name: Push version bumps and tags
        run: git push origin main --follow-tags || echo "Nothing to push"

      - name: Create GitHub Release
        if: steps.bump.outputs.gcp_version != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.bump.outputs.gcp_version }}"
          gh release create "gcp-v${VERSION}" \
            --title "pragmatiks-gcp-provider v${VERSION}" \
            --generate-notes \
            dist/pragmatiks_gcp_provider-${VERSION}* || echo "Release may already exist"

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages-dir: dist/
          skip-existing: true

      - name: Publish gcp to pragma store
        if: steps.bump.outputs.gcp_version != ''
        continue-on-error: true
        env:
          PRAGMA_AUTH_TOKEN: ${{ secrets.PRAGMA_CI_CLERK_TOKEN }}
        run: |
          cd packages/gcp
          uv run pragma providers publish --version "${{ steps.bump.outputs.gcp_version }}" --org pragmatiks

  # Tier 2: Providers that depend on tier 1
  publish-tier-2:
    needs: [detect-changes, publish-tier-1]
    if: |
      always() &&
      (needs.detect-changes.outputs.kubernetes == 'true' || needs.detect-changes.outputs.qdrant == 'true') &&
      (needs.publish-tier-1.result == 'success' || needs.publish-tier-1.result == 'skipped')
    runs-on: ubuntu-latest
    environment: pypi
    permissions:
      contents: write
      id-token: write
    outputs:
      kubernetes_version: ${{ steps.bump.outputs.kubernetes_version }}
      qdrant_version: ${{ steps.bump.outputs.qdrant_version }}

    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main
          token: ${{ steps.app-token.outputs.token }}

      - name: Pull latest changes
        run: git pull origin main

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          version: "0.5.x"

      - name: Set up Python
        run: uv python install 3.13

      - name: Install commitizen
        run: uv tool install commitizen

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Wait for PyPI availability
        if: needs.publish-tier-1.outputs.gcp_version != ''
        run: |
          PACKAGE="pragmatiks-gcp-provider"
          VERSION="${{ needs.publish-tier-1.outputs.gcp_version }}"
          echo "Waiting for $PACKAGE v$VERSION on PyPI..."
          for i in {1..30}; do
            if curl -sf "https://pypi.org/pypi/$PACKAGE/$VERSION/json" > /dev/null; then
              echo "Package available on PyPI"
              exit 0
            fi
            echo "Attempt $i: Package not yet available, waiting 10s..."
            sleep 10
          done
          echo "Timed out waiting for package on PyPI"
          exit 1

      - name: Bump and build tier 2 providers
        id: bump
        env:
          CHANGED_KUBERNETES: ${{ needs.detect-changes.outputs.kubernetes }}
          CHANGED_QDRANT: ${{ needs.detect-changes.outputs.qdrant }}
        run: |
          process_provider() {
            local provider=$1
            echo "::group::Processing $provider"
            cd packages/$provider

            if cz bump --yes --changelog 2>&1 | tee bump_output.txt; then
              VERSION=$(cz version --project)
              echo "Bumped $provider to v$VERSION"
              echo "${provider}_version=$VERSION" >> $GITHUB_OUTPUT
              uv build --package pragmatiks-${provider}-provider --out-dir ../../dist
            else
              if grep -qE "No commits found|is not a bump" bump_output.txt; then
                echo "No bump needed for $provider"
              else
                cat bump_output.txt
                exit 1
              fi
            fi

            cd ../..
            echo "::endgroup::"
          }

          if [ "$CHANGED_KUBERNETES" = "true" ]; then
            process_provider kubernetes
          fi

          if [ "$CHANGED_QDRANT" = "true" ]; then
            process_provider qdrant
          fi

      - name: Push version bumps and tags
        run: git push origin main --follow-tags || echo "Nothing to push"

      - name: Create GitHub Release for kubernetes
        if: steps.bump.outputs.kubernetes_version != ''
        run: |
          VERSION="${{ steps.bump.outputs.kubernetes_version }}"
          gh release create "kubernetes-v${VERSION}" \
            --title "pragmatiks-kubernetes-provider v${VERSION}" \
            --generate-notes \
            dist/pragmatiks_kubernetes_provider-${VERSION}* || echo "Release may already exist"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create GitHub Release for qdrant
        if: steps.bump.outputs.qdrant_version != ''
        run: |
          VERSION="${{ steps.bump.outputs.qdrant_version }}"
          gh release create "qdrant-v${VERSION}" \
            --title "pragmatiks-qdrant-provider v${VERSION}" \
            --generate-notes \
            dist/pragmatiks_qdrant_provider-${VERSION}* || echo "Release may already exist"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages-dir: dist/
          skip-existing: true

      - name: Publish kubernetes to pragma store
        if: steps.bump.outputs.kubernetes_version != ''
        continue-on-error: true
        env:
          PRAGMA_AUTH_TOKEN: ${{ secrets.PRAGMA_CI_CLERK_TOKEN }}
        run: |
          cd packages/kubernetes
          uv run pragma providers publish --version "${{ steps.bump.outputs.kubernetes_version }}" --org pragmatiks

      - name: Publish qdrant to pragma store
        if: steps.bump.outputs.qdrant_version != ''
        continue-on-error: true
        env:
          PRAGMA_AUTH_TOKEN: ${{ secrets.PRAGMA_CI_CLERK_TOKEN }}
        run: |
          cd packages/qdrant
          uv run pragma providers publish --version "${{ steps.bump.outputs.qdrant_version }}" --org pragmatiks

  # Tier 3: Providers that depend on tier 2
  publish-tier-3:
    needs: [detect-changes, publish-tier-1, publish-tier-2]
    if: |
      always() &&
      needs.detect-changes.outputs.agno == 'true' &&
      (needs.publish-tier-1.result == 'success' || needs.publish-tier-1.result == 'skipped') &&
      (needs.publish-tier-2.result == 'success' || needs.publish-tier-2.result == 'skipped')
    runs-on: ubuntu-latest
    environment: pypi
    permissions:
      contents: write
      id-token: write

    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main
          token: ${{ steps.app-token.outputs.token }}

      - name: Pull latest changes
        run: git pull origin main

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          version: "0.5.x"

      - name: Set up Python
        run: uv python install 3.13

      - name: Install commitizen
        run: uv tool install commitizen

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Wait for PyPI availability
        run: |
          wait_for_package() {
            local package=$1
            local version=$2
            echo "Waiting for $package v$version on PyPI..."
            for i in {1..30}; do
              if curl -sf "https://pypi.org/pypi/$package/$version/json" > /dev/null; then
                echo "Package available on PyPI"
                return 0
              fi
              echo "Attempt $i: Package not yet available, waiting 10s..."
              sleep 10
            done
            echo "Timed out waiting for $package v$version on PyPI"
            return 1
          }

          # Wait for kubernetes if it was just published
          if [ -n "${{ needs.publish-tier-2.outputs.kubernetes_version }}" ]; then
            wait_for_package pragmatiks-kubernetes-provider "${{ needs.publish-tier-2.outputs.kubernetes_version }}"
          fi

          # Wait for qdrant if it was just published
          if [ -n "${{ needs.publish-tier-2.outputs.qdrant_version }}" ]; then
            wait_for_package pragmatiks-qdrant-provider "${{ needs.publish-tier-2.outputs.qdrant_version }}"
          fi

          # Wait for gcp if it was just published
          if [ -n "${{ needs.publish-tier-1.outputs.gcp_version }}" ]; then
            wait_for_package pragmatiks-gcp-provider "${{ needs.publish-tier-1.outputs.gcp_version }}"
          fi

      - name: Bump and build agno
        id: bump
        run: |
          echo "::group::Processing agno"
          cd packages/agno

          if cz bump --yes --changelog 2>&1 | tee bump_output.txt; then
            VERSION=$(cz version --project)
            echo "Bumped agno to v$VERSION"
            echo "agno_version=$VERSION" >> $GITHUB_OUTPUT

            uv build --package pragmatiks-agno-provider --out-dir ../../dist
          else
            if grep -qE "No commits found|is not a bump" bump_output.txt; then
              echo "No bump needed for agno"
            else
              cat bump_output.txt
              exit 1
            fi
          fi

          cd ../..
          echo "::endgroup::"

      - name: Push version bumps and tags
        run: git push origin main --follow-tags || echo "Nothing to push"

      - name: Create GitHub Release
        if: steps.bump.outputs.agno_version != ''
        run: |
          VERSION="${{ steps.bump.outputs.agno_version }}"
          gh release create "agno-v${VERSION}" \
            --title "pragmatiks-agno-provider v${VERSION}" \
            --generate-notes \
            dist/pragmatiks_agno_provider-${VERSION}* || echo "Release may already exist"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Publish to PyPI
        if: steps.bump.outputs.agno_version != ''
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages-dir: dist/
          skip-existing: true

      - name: Publish agno to pragma store
        if: steps.bump.outputs.agno_version != ''
        continue-on-error: true
        env:
          PRAGMA_AUTH_TOKEN: ${{ secrets.PRAGMA_CI_CLERK_TOKEN }}
        run: |
          cd packages/agno
          uv run pragma providers publish --version "${{ steps.bump.outputs.agno_version }}" --org pragmatiks
